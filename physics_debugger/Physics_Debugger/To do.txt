---- TO DO ----
- Proper error handling in the network layer
- Packets broken into chunks
- Cope with fixed packet size, and breaking down the data into multiple packets for transmission - and reconstruct them on the other end
- Errors for packets that were missed/lost
- Cope with packets arriving out of order in the primary frame data object (needs to sort the frame data based on frame id)
- Conduit to send data back to the physics engine?
	- Mouse clicks so you can interact with physics objects from the physics debugger and drag them around in the physics engine side world
- Read generic properties
- Send debug render commands
- Profile markers
	- Display hot frames
	- Histogram of frame processing times (configurable time "budget")
- Memory usage
	- Display hot frames (nearly out of memory budget)
	- Display histogram of frames (nearly out of memory budget)
- Formalise the physics engine side code so it can be included in other projects
	- send/receive data from the debugger application
	- save data to a file
	- load data from a file and playback?
	- Rigid body ID's
- Save telemetry to file
- Open telemetry from file
- Display object properties in the debugger
- Scene explorer tree view in the debugger?
- Clickable objects in the viewport to select them to display their data in the debugger
- Send more data types
	- Shape information - meshes + arbitrary meshes
	- Compount shapes
	- Contacts
	- Forces added
	- Physics engine function calls?
	- Origin rebase?
- Make render instances 1:1 with their rigid body, so they're directly ascociated?
- Thread network communication in the client and visual debugger.
- Disconnect option and handling a forced disconnection if the "game" drops out
- Swap telemetry data source to protobuff?
- Proper error handling in the file handling (common exceptions)
- Align network transmission format and file save/load so they're the same format?
- Export a subset of frames to file? If you have a big run, but only need a bit of it? Or you want to share a snapshot.
- Does telemetry need to be broken up into multiple files, so after recording n frames, it's dumped to file and the editor is reset, so memory usage doesn't get out of hand,
but also so you could record a really long run! Would need some special logic in the loading to put segments together.
- Adjust playback speed
	- Configurable step size on the frame scrubber?
- Camera Speed adjuster
- Draw a wireframe ground plane to help with orientation
- Allow "game" to send an idea camera position to the viewer so it can mirror the game play camera
- Mesh Types
	- Sphere
	- Cone
	- Capsule
	- Cylinder
	- Arbitrary mesh (triangle list)
- Connecting to an "in progress" session

---- DONE ----
- Proper frame scrubbing controls
- playback modes
	- play/pause
	- Scrub through the telemetry we've been sent
- Mesh types
	- Tetrahedron

----Notes----
Packets are prescriptive now, but the version when we can generate the serialisation/deserialisation code, I'm thinking about using shader style Semantics, to infer/retrieve what I NEED to render the scene. You can mark the 
properties that should be interpretted as semantic values so I know what they are so can use them for rendering purposes - e.g. position/orientation/velocity etc.

What about multi-world games - where they have multiple physics worlds you might want to collect data for. They'll each need their own "telemetry world" for gathering frame data. They could be running at different frame
rates. Should they use the same network connection and the packet translator splits it up into the correct world, so there's only 1 data stream? Or, create a data stream for each world and exchange ports to use for each
one on initial connection - or via some sort of connection manager? The base packet could have a world ID or world name. The debugger could then allow the user to select which world to collect data for - defaulting to 
collect all channels though, so no data is missed.

-- Network/data source structuring --

|----------------Telemetry source-------------------|
|DataStream ---> Packet Accumulator? ---> Translator|  --queue-> Frame Data
|---------------------------------------------------|

You may want to accumulate telemetry from multiple sources simutaneously - so passing in a data stream to use is good - or at least specify the address. If you're collecting from multiple sources you'll need a complete
pipeline for each source, or to dump all data whenever you swap source as there's no real way to merge the two.
Memory snooping is another "telemetry source", so it should be interfaced, so you can swap between them as a mode of running - e.g. when the target application hits a break point, you can swap to snoop mode, where
it can continue to process data for the same physics engine instance, except it's data source is a memory snooper.
Files may also be another source of data?

----Bugs----
Drag the splitters to make the DirectX control have zero height causes an assert - likely the same thing happens if you do it to the width too.